#include "include/helper_funcs.h"

/*
Mandelbort set visualizer, it takes complex image plane as an input (e.g. generated by complex_plane.blink)

complex numbers are stored in vec2(X, Y) type, where X is real and Y is imaginary part
*/

kernel mandelbrot : ImageComputationKernel<ePixelWise>
{
    Image<eRead, eAccessPoint, eEdgeNone> c_src;
    Image<eWrite> dst;

    param:
        int max_iter;
        int julia_mode;
        float2 julia_coord;
        int color_mode;
        float2 orbit_pt;
        float2 orbit_line_pt_1;
        float2 orbit_line_pt_2;

    local:

    void define() {
        defineParam(max_iter, "Maximum iterations", 1000);
        defineParam(julia_mode, "Julia mode", 0);
        defineParam(julia_coord, "Julia coordinate", float2(0.0f, 0.0f));
        defineParam(color_mode, "Color mode", 1);
        defineParam(orbit_pt, "Orbit point coordinate", float2(0.0f, 0.0f));
        defineParam(orbit_line_pt_1, "Orbit line point 1 coordinate", float2(0.0f, 0.0f));
        defineParam(orbit_line_pt_2, "Orbit line point 2 coordinate", float2(1.0f, 1.0f));
    }

    void init() {
    }

    void process(int2 pos)
    {
        float2 c = float2(c_src(0), c_src(1));
        float2 z = c;
        float2 z0 = z;
        float2 z_next;
        int i = 0;

        float col_smooth = exp( -dot(z,z) );

        float orbit_pt_dist = 10e10;
        float orbit_coord_dist = 10e10;
        float orbit_line_dist = 10e10;

        if (julia_mode)
            c = julia_coord;

        for (; i < max_iter; i++)
        {
            // iterative function
            z_next.x = z.x * z.x - z.y * z.y + c.x;
            z_next.y = 2 * z.x * z.y + c.y;
            z = z_next;

            // colors
            col_smooth += exp( -dot(z,z) );

            // orbit traps
            orbit_pt_dist = min(orbit_pt_dist, fabs( dot(z, orbit_pt) ));
            orbit_coord_dist = min(orbit_coord_dist, fabs( dot(z, z0) ));
            orbit_line_dist = min(orbit_line_dist, fabs( distPtLine(z, orbit_line_pt_1, orbit_line_pt_2) ));

            if (dot(z, z) > 4)
                break;
        }

        col_smooth /= float(max_iter);

        float col_steps = float(i) / float(max_iter);
        if (i == max_iter)
            col_steps = 0.0f;

        //orbit_coord_dist = log(orbit_coord_dist);
        //orbit_pt_dist = log(orbit_pt_dist);
        //orbit_line_dist = log(orbit_line_dist);

        orbit_coord_dist = fmod(orbit_coord_dist, 1);
        //orbit_pt_dist = fmod(orbit_pt_dist, 1);
        orbit_line_dist = fmod(orbit_line_dist, 1);

        float3 out_col;

        if (color_mode == 0)
            out_col = float3(col_steps);
        else if (color_mode == 1)
            out_col = float3(col_smooth);
        else if (color_mode == 2)
            out_col = float3(orbit_pt_dist, orbit_coord_dist, orbit_line_dist);

        dst() = float4(out_col.x, out_col.y, out_col.z, 1);
    }
};