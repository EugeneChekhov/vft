#include "include/vft_blink.h"

/*
Mandelbort set visualizer, it takes complex image plane as an input (e.g. generated by complex_plane.blink)

complex numbers are stored in vec2(X, Y) type, where X is real and Y is imaginary part
*/

kernel mandelbrot : ImageComputationKernel<ePixelWise>
{
    Image<eRead, eAccessPoint, eEdgeNone> c_src;
    Image<eWrite> dst;

    param:
        int max_iter;
        int julia_mode;
        float2 julia_coord;
        int color_mode;
        float2 orbit_pt;
        float2 orbit_line_pt_1;
        float2 orbit_line_pt_2;
        float2 orbit_circle_center;
        float orbit_circle_radius;

    local:

    void define() {
        defineParam(max_iter, "Maximum iterations", 1000);
        defineParam(julia_mode, "Julia mode", 0);
        defineParam(julia_coord, "Julia coordinate", float2(0.0f, 0.0f));
        defineParam(color_mode, "Color mode", 1);
        defineParam(orbit_pt, "Orbit point coordinate", float2(0.0f, 0.0f));
        defineParam(orbit_line_pt_1, "Orbit line point 1 coordinate", float2(0.0f, 0.0f));
        defineParam(orbit_line_pt_2, "Orbit line point 2 coordinate", float2(1.0f, 1.0f));
        defineParam(orbit_circle_center, "Orbit circle coordinate", float2(1.0f, 1.0f));
        defineParam(orbit_circle_radius, "Orbit circle radius", 100.0f);
    }

    void init() {
    }

    void process(int2 pos)
    {
        float2 c = float2(c_src(0), c_src(1));
        float2 complex_pos = c;
        float2 z = c;
        float2 z0 = z;
        float2 z_next;
        int i = 0;

        float col_smooth = exp( -dot(z,z) );

        float orbit_pt_dist = LARGE_NUMBER;
        float orbit_coord_dist = LARGE_NUMBER;
        float orbit_line_dist = LARGE_NUMBER;
        float orbit_circle_dist = LARGE_NUMBER;

        if (julia_mode)
            c = julia_coord;

        for (; i < max_iter; i++)
        {
            // iterative function
            z_next.x = z.x * z.x - z.y * z.y + c.x;
            z_next.y = 2 * z.x * z.y + c.y;
            z = z_next;

            // colors
            col_smooth += exp( -dot(z,z) );

            // orbit traps
            if (color_mode == 2)
            {
                orbit_pt_dist = min(orbit_pt_dist, fabs( dot(z - orbit_pt, z - orbit_pt) ));
                orbit_coord_dist = min(orbit_coord_dist, fabs( dot(z - z0, z - z0) ));
                orbit_line_dist = min(orbit_line_dist, fabs( distPtLine(z, orbit_line_pt_1, orbit_line_pt_2) ));
                orbit_circle_dist = min(orbit_circle_dist, fabs( distPtCircle(z, orbit_circle_center, orbit_circle_radius) ));
            }

            if (dot(z, z) > 4)
                break;
        }

        orbit_pt_dist = sqrt(orbit_pt_dist);
        orbit_coord_dist = sqrt(orbit_coord_dist);

        float4 out_col;
        float col_steps;
        float vis_min;

        if (color_mode == 0) // steps shading
        {
            col_steps = float(i) / float(max_iter);
            if (i == max_iter)
                col_steps = 0.0f;

            out_col = float4(col_steps, col_steps, col_steps, 1.0);
        }

        else if (color_mode == 1) // smooth shading
        {
            col_smooth /= float(max_iter);
            
            out_col = float4(col_smooth, col_smooth, col_smooth, 1.0);
        }

        else if (color_mode == 2) // orbit traps
        {
            out_col = float4(orbit_pt_dist, orbit_coord_dist, orbit_line_dist, orbit_circle_dist);
        }

        else if (color_mode == 3) // orbit traps visualization
        {
            vis_min = min(
                sqrt( fabs( dot(float2(pos) - orbit_pt, float2(pos) - orbit_pt) )) * 0.0001f, 
                fabs( distPtLine(pos, orbit_line_pt_1, orbit_line_pt_2) ) * 0.0001f
            );

            vis_min = min(
                vis_min,
                fabs( distPtCircle(pos, orbit_circle_center, orbit_circle_radius) ) * 0.0001f
            );
            
            out_col = float4(vis_min, vis_min, vis_min, 1.0f);
        }

        dst() = float4(out_col.x, out_col.y, out_col.z, out_col.w);
    }
};